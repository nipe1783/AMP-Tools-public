// this function sets-up an ompl planning problem for an arbitrary number of agents
og::SimpleSetupPtr geometricSimpleSetUp(const World *w)
{
    // grab the agent -- assume only one
    Agent *a = w->getAgents()[0];

    // create state space (with bounds)
    auto space(std::make_shared<ob::SE2StateSpace>());
    ob::RealVectorBounds bounds(2);
    bounds.setLow(0, 0);
    bounds.setHigh(0, w->getWorldDimensions()[0]);
    bounds.setLow(1, 0);
    bounds.setHigh(1, w->getWorldDimensions()[1]);
    space->setBounds(bounds);
 
    // define a simple setup class
    auto ss = std::make_shared<og::SimpleSetup>(space);
    
    // set state validity checker
    ss->setStateValidityChecker(std::make_shared<isStateValid_2D>(ss->getSpaceInformation(), w, a));
    
    // create start
    ob::ScopedState<ob::SE2StateSpace> start(space);
    start->setX(a->getStartLocation()[0]);
    start->setY(a->getStartLocation()[1]);
    start->setYaw(0.0);

    // create goal
    ob::ScopedState<ob::SE2StateSpace> goal(space);
    goal->setX(a->getGoalLocation()[0]);
    goal->setY(a->getGoalLocation()[1]);
    goal->setYaw(0.0);

    // save start and goal with tolerance
    ss->setStartAndGoalStates(start, goal, 0.1);

    OMPL_INFORM("Successfully Setup the problem instance");
    return ss;
}

// this function sets-up an ompl planning problem for an arbitrary number of agents
og::SimpleSetupPtr geometricSimpleSetUpAMP(const Problem2D *prob)
{
    // grab the agent -- assume only one
    Agent *a = w->getAgents()[0];

    // create state space (with bounds)
    auto space(std::make_shared<ob::SE2StateSpace>());
    ob::RealVectorBounds bounds(2);
    bounds.setLow(0, prob->x_min);
    bounds.setHigh(0, prob->x_max);
    bounds.setLow(1, prob->y_min);
    bounds.setHigh(1, w->getWorldDimensions()[1]);
    space->setBounds(bounds);
 
    // define a simple setup class
    auto ss = std::make_shared<og::SimpleSetup>(space);
    
    // set state validity checker
    ss->setStateValidityChecker(std::make_shared<isStateValid_2D>(ss->getSpaceInformation(), w, a));
    
    // create start
    ob::ScopedState<ob::SE2StateSpace> start(space);
    start->setX(a->getStartLocation()[0]);
    start->setY(a->getStartLocation()[1]);
    start->setYaw(0.0);

    // create goal
    ob::ScopedState<ob::SE2StateSpace> goal(space);
    goal->setX(a->getGoalLocation()[0]);
    goal->setY(a->getGoalLocation()[1]);
    goal->setYaw(0.0);

    // save start and goal with tolerance
    ss->setStartAndGoalStates(start, goal, 0.1);

    OMPL_INFORM("Successfully Setup the problem instance");
    return ss;
}

// main planning function -- uses simple setup
og::PathGeometric planGeometric(std::string planner_string)
{
    // create world from YAML file
    World *w = yaml2world("/home/nic/dev/ASEN_5254/ASEN_5254_Project/AMP-Tools-public/ws/ompl-demo/Problem.yml");
    // create simple setup object
    og::SimpleSetupPtr ss = geometricSimpleSetUp(w);


    // create path
    og::PathGeometric path(ss->getSpaceInformation());

    // set planner
    ob::PlannerPtr planner = nullptr;
    if (planner_string == "RRT")
        planner = std::make_shared<og::RRT>(ss->getSpaceInformation());
    else if (planner_string == "SST")
        planner = std::make_shared<og::SST>(ss->getSpaceInformation());
    else
    {
        OMPL_WARN("Planner %s not found. Defaulting to RRT", planner_string.c_str());
        planner = std::make_shared<og::RRT>(ss->getSpaceInformation());
    }
    ss->setPlanner(planner);

    // run automated setup routine
    ss->setup();
    
    // solve the instance
    bool solved = ss->solve(30.0);
    if (solved)
    {
        ss->simplifySolution();
        path = ss->getSolutionPath();
    }
    else
    {
        OMPL_WARN("No solution found");
    }
    return path;
}


main:

std::cout<<pathOMPL.getStates().size()<<std::endl;
for(int i = 0; i < pathOMPL.getStates().size(); i++){
    path.waypoints.push_back(Eigen::Vector2d(pathOMPL.getStates()[i]->as<ob::SE2StateSpace::StateType>()->getX(), pathOMPL.getStates()[i]->as<ob::SE2StateSpace::StateType>()->getY()));
}